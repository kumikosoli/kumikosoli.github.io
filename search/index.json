[{"content":"cs61b-sp21 笔记\r作者 ： Kumikosoli\rpackage(包)\r把多个类封装在一个包中，用于完成共同的功能。 意义\r如org.junit.Assert.assertArrayEquals中，org.junit是包,Assert是类名，assertArrayEquals 是方法名\n用法\r在每个类文件开头加上 package package_name 表示这个类在包中\n引用\rjava中，除八种基本类型外，其他类型都是作为引用被初始化,引用变量存储的是指向结构的地址 使用junit进行test\r使用org.junit.Assert.assertArrayEquals(expected,input)验证输入与期望的数组是否相等 Debug工具\rconditional breakpoint:条件断点，当且仅当在该断点处满足条件为True时才会停止 resume:恢复程序，使程序继续运行直到回到断点 链表Linklist\rnested class：嵌套类，在类中定义一个类。在list类中定义node类，把初始化的list作为头节点。\n为链表提供头节点可简化添加元素时的代码。\n对于双向链表，可添加头尾两个哨兵节点或者将链表设置为环，简化删除、添加节点等代码。\n类中可将成员类型推迟到初始化或声明中决定。具体代码\n1 2 3 4 5 6 7 8 9 10 public class Sllist\u0026lt;BleepBLORP\u0026gt;{ private Node sentinel private int size public class Node{ public BleepBlorp item; public Node next; ………… } } ………… 使用时在初始化对象时语法 Sllist\u0026lt;String\u0026gt; lt1 = new Sllist\u0026lt;\u0026gt;(\u0026quot;Hi!\u0026quot;) \u0026lt;\u0026gt;中的泛型要使用引用类型。 对应关系：\n基本类型 引用 double Double int Integer char Character boolean Boolean long Long 类继承\rimplement\r形如public class RotatingSLList\u0026lt;Item\u0026gt; implement SLList\u0026lt;Item\u0026gt;的类定义，用于表示类继承，子类拥有父类中定义的所有方法（一般要在子类中写出继承的接口的实现）。也可以用父类中已定义好的方法。\n哪怕父类中已经定义了方法，也可以在子类中重写。在方法上方添加 @override 显式表示这是继承自父类的方法并给出定义。 extends\r形如public class RotatingSLList\u0026lt;Item\u0026gt; extends SLList\u0026lt;Item\u0026gt;的类定义，表示子类继承了父类的所有非private成员（属性、方法、嵌套类）,可以直接使用，并且可以在子类中添加新的方法等。\nextends创建的子类，在调用构造函数时首先调用父类的构造函数，然后再回到子类新的构造函数中。 可以显式调用父类构造函数super()，若不显式调用，编译器会自动完成。 interface\r与类相似，定义类似public interface Mycontrast{……} ，但其中只能包含子类需要实现的方法，并在子类中给出定义。 子类通过implement继承interface，一个子类可以继承多个interface。\n高阶函数\rjava没有函数指针，无法直接传递函数。想要使用类似函数指针的效果，可以通过interface和类继承，让子类implement同一个接口override接口的方法，并将子类传入函数中充当函数指针作用。例如\n1 2 3 public static int do_twice(IntUnaryFunction f, int x) { return f.apply(f.apply(x)); } java库 java.util\r内含多种数据结构\nList interface\r具有子类Arraylist\nhashset\rjava的set interface 的子类\nSets\r存储不重复元素的无序集合。\n方法\radd() 加入元素 contain() 检测是否包含元素 size() 返回集合大小 异常处理\rthrow 关键字\r使用格式throw new ExceptionObject(parameter1, ...) 例子： 1 2 3 if (x == null) { throw new IllegalArgumentException(\u0026#34;can\u0026#39;t add null\u0026#34;); } new 后的是异常类；括号中的是对异常的解释。\nIteration\r1 2 3 for (String city : s) { System.out.println(city); } 这是对for循环的强化使用。其具体为：\n1 2 3 4 5 6 7 Set\u0026lt;String\u0026gt; s = new HashSet\u0026lt;\u0026gt;(); ... Iterator\u0026lt;String\u0026gt; seer = s.iterator(); while (seer.hasNext()) { String city = seer.next(); ... } 因此，若想在自己定义的类中使用迭代器，则需要让此类extend Iterable\u0026lt;T\u0026gt;``iteratior()方法返回一个iterator对象。该对象应在类中定义私有嵌套类（定义hasNext方法和next方法），此时就可以使用第二个的具体形式。 如果想要使用简洁的for(T city : s)形式，则需要给嵌套的Iterator类加上implement Iterator()\nObject\r所有类都隐式继承了Object类，拥有其定义的方法。常用的为String tostring()和boolean equals(Object obj)。一般需要在自己定义的类中override这些方法\ntoString\r在发生类到String的类型转换时会隐性调用。默认实现是返回类存储的地址。\n由于使用 String a=a+\u0026ldquo;qqq\u0026quot;时会产生新的字符串，时间复杂度为$O(n)$，Java新增了StringBuilder类使拼接字符串的时间复杂度为 $ O(1) $。 使用StringBuilder类凭借字符串代码如下：\n1 2 3 4 5 6 7 8 9 10 public String toString() { StringBuilder returnSB = new StringBuilder(\u0026#34;{\u0026#34;); for (int i = 0; i \u0026lt; size - 1; i += 1) { returnSB.append(items[i].toString()); returnSB.append(\u0026#34;, \u0026#34;); } returnSB.append(items[size - 1]); returnSB.append(\u0026#34;}\u0026#34;); return returnSB.toString(); } equals\r默认对比两个对象地址是否相同（等价于==），返回True/False. 通过重写可以比较对象不同的属性。\nData Structure 部分\r时间复杂度\r$Θ(f(n))$\r代表时间复杂度与 $f(n)$ 同阶\n$O(f(n))$\r代表时间复杂度与 $f(n)$ 同阶或更低阶\n","date":"2025-03-31T13:46:55+08:00","permalink":"http://localhost:1313/p/cs61b-sp21_%E7%AC%94%E8%AE%B0/","title":"Cs61b Sp21_笔记"},{"content":" 简单进度记录 written by kumikosoli 2025/3/27\r看完CS50 Lecture1后得到友人启发，转为学习CS61b：Java版数据结构。\n进行事项\rLecture1 尝试setup学习环境 2025/3/28\r尝试配环境的第二天。\n进行事项\rHomework0 Lecture2 搭建环境 2025/3/29\r在外面和高中同学🐍逛了一整天……午饭双人鸡公煲-\u0026gt;合生广场获取pjsk联动-\u0026gt;游园会购入社刊-\u0026gt;美味多晚饭、观看docker直播课-\u0026gt;回宿舍打烤。最终熬夜尝试完成Project0。\n进行事项\rProject0 2025/3/30\r整天呆在宿舍，但是只完成Project0收尾+一个Lecture+一个lab，该检讨自己的学习态度了……原因主要是刷手机和突然出现的聊天热潮（看来自己没想象中那么不受欢迎）。尝试用 hugo 和 github page 部署自己的博客，未成功。\n进行事项\rProject0 Lecture3 Lab2 配好了CS61b需要的环境 (感谢Github Desktop) 部署自己的博客 2025/3/31\r用中午和晚上公选时间看完一个lecture，感觉前面的内容过于基础没学到什么……同时耗费大量时间把个人博客部署好了，但是还没开始设置，简单地把文档放上去就结束了……\n进行事项\rLecture4 部署个人博客 2025/4/1\r在万恶的手机之下，今天看了1.5个Lecture,进展龟速……但是终于到链表了。\n进行事项\rLexture5 Lecture6 ","date":"2025-03-31T13:45:26+08:00","permalink":"http://localhost:1313/p/%E7%AE%80%E5%8D%95%E8%BF%9B%E5%BA%A6%E8%AE%B0%E5%BD%95/","title":"简单进度记录"}]